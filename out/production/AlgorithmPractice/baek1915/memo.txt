

이 문제를 왼쪽 위 x-1,y-1로 나누어 생각하는것은 맞다, 그러나 dp의 성질을 생각해보면, 이 문제는

dp가 가지고있는 성질을 최대한 잘 사용해야 정확하고 간결하게 풀 수 있다는것을 명심해야한다, 또한 map을 배열로 받아오는

입력문을 정확하게 해서 디버깅하는 시간을 줄이도록 하자,

'맵은 꼭 그려보며' 입력문을 받고, '입력문은 두번읽고'  실수를 줄인다.





dp[][] 에는 메모아이징 기법이 굉장히 중요한데, 이 문제는 연산결과를 저장하면서 진행하는 방식으로 하기때문에

굳이 연산을 여러번하지않아도 된다.



핵심 알고리즘은 x,y 가 1이면 Math.min( dp[x-1][y] , dp[x-1][y-1], dp[x][y-1] ) 이 세가지 중에서 제일 작은거에 하나를 더한값이 자신의
dp값이다. 라는것이다.




내 코드의 문제점 : dp에 저장되어있는 값이 의미하는 성질을 제대로 이용하지 못했다. 완전탐색에 집착 for문에 집착하지말자.

                    그리고 한칸전의 정보로 두칸 , 세칸 전의 정보를 사용할 수 있다면 사용하는것이 좋다,.'

